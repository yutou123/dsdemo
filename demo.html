<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Crypto K-line Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.3.2/dist/echarts.min.js"></script>
    <style>
        .controls { margin: 20px; padding: 10px; background: #f5f5f5; }
        .status { color: #666; font-size: 0.9em; }
        .suggestion { padding: 10px; margin: 10px; border-radius: 5px; }
        .long { background: #e8f5e9; color: #2e7d32; }
        .short { background: #ffebee; color: #c62828; }
    </style>
</head>
<body>
    <div class="controls">
        <div>
            <label for="symbol">交易对:</label>
            <input type="text" id="symbol" value="BTCUSDT" placeholder="大写字母 (例: BTCUSDT)">
            <button onclick="handleSymbolChange()">切换</button>
        </div>
        <div style="margin-top: 10px;">
            <label for="interval">周期:</label>
            <select id="interval" onchange="handleIntervalChange()">
                <option value="1m">1分钟</option>
                <option value="15m">15分钟</option>
                <option value="1h">1小时</option>
                <option value="4h">4小时</option>
                <option value="1d">1日线</option>
            </select>
        </div>
        <div class="status" id="status">连接中...</div>
    </div>

    <div id="chart" style="width: 100%;height:600px;"></div>
    <div id="suggestion" class="suggestion"></div>

    <script>
        let myChart = echarts.init(document.getElementById('chart'));
        let ws = null;
        let currentSymbol = 'BTCUSDT';
        let currentInterval = '1m';
        let kLinesData = [];
        let reconnectAttempts = 0;

        // 初始化图表配置
        function initChart() {
            const option = {
                title: { text: `${currentSymbol} K线图`, left: 'center' },
                tooltip: { trigger: 'axis', axisPointer: { type: 'cross' } },
                xAxis: { type: 'time', boundaryGap: false },
                yAxis: { scale: true, splitLine: { show: true } },
                dataZoom: [{
                    type: 'inside',
                    start: 95,
                    end: 100
                }],
                series: [{
                    type: 'candlestick',
                    itemStyle: {
                        color: '#00da3c',
                        color0: '#ec0000',
                        borderColor: '#008F28',
                        borderColor0: '#8B0000'
                    },
                    data: []
                }]
            };
            myChart.setOption(option);
        }

        // 初始化WebSocket连接
        function initWebSocket() {
            const symbol = currentSymbol.toLowerCase();
            const interval = currentInterval;
            
            if (!/^[A-Z]{3,10}USDT$/.test(currentSymbol)) {
                showError('无效的交易对格式');
                return;
            }

            if (ws) ws.close();
            
            ws = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol}@kline_${interval}`);
            
            ws.onopen = () => {
                updateStatus('已连接');
                reconnectAttempts = 0;
                loadHistoryData();
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                processKLineData(data.k);
            };

            ws.onerror = (error) => {
                showError('连接错误');
                attemptReconnect();
            };

            ws.onclose = () => {
                updateStatus('连接断开');
                attemptReconnect();
            };
        }

        // 加载历史数据
        async function loadHistoryData() {
            try {
                const response = await fetch(
                    `https://api.binance.com/api/v3/klines?symbol=${currentSymbol}&interval=${currentInterval}&limit=100`
                );
                const history = await response.json();
                kLinesData = history.map(k => ({
                    time: k[0],
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    volume: parseFloat(k[5])
                }));
                updateChart();
            } catch (error) {
                showError('历史数据加载失败');
            }
        }

        // 处理K线数据
        function processKLineData(kline) {
            const newKLine = {
                time: kline.t,
                open: parseFloat(kline.o),
                high: parseFloat(kline.h),
                low: parseFloat(kline.l),
                close: parseFloat(kline.c),
                volume: parseFloat(kline.v)
            };

            // 更新数据系列
            if (kLineExists(newKLine.time)) {
                kLinesData[kLinesData.length - 1] = newKLine;
            } else {
                kLinesData.push(newKLine);
            }

            updateChart();
            updateTradingSuggestion();
        }

        // 更新图表
        function updateChart() {
            const option = {
                title: { text: `${currentSymbol} ${currentInterval} K线图` },
                series: [{
                    data: kLinesData.map(k => [
                        k.time,
                        k.open,
                        k.close,
                        k.low,
                        k.high
                    ])
                }]
            };
            myChart.setOption(option);
        }

        // 生成交易建议
        function updateTradingSuggestion() {
            if (kLinesData.length < 2) return;

            const current = kLinesData[kLinesData.length - 1];
            const prev = kLinesData[kLinesData.length - 2];
            
            // 简单趋势分析
            const priceChange = current.close - prev.close;
            const volumeChange = current.volume - prev.volume;
            
            let suggestion = '';
            let confidence = 0;

            if (priceChange > 0 && volumeChange > 0) {
                suggestion = '做多';
                confidence = Math.min(95, (priceChange/prev.close)*10000 + (volumeChange/prev.volume)*50);
            } else if (priceChange < 0 && volumeChange > 0) {
                suggestion = '做空';
                confidence = Math.min(95, Math.abs(priceChange/prev.close)*10000 + (volumeChange/prev.volume)*50);
            } else {
                suggestion = '保持观望';
                confidence = 50;
            }

            const suggestionElement = document.getElementById('suggestion');
            suggestionElement.className = `suggestion ${suggestion === '做多' ? 'long' : 'short'}`;
            suggestionElement.innerHTML = `
                <strong>未来30分钟建议:</strong> ${suggestion}<br>
                <em>信心指数:</em> ${confidence.toFixed(1)}%<br>
                <small>最后更新: ${new Date().toLocaleTimeString()}</small>
            `;
        }

        // 辅助函数
        function kLineExists(timestamp) {
            return kLinesData.some(k => k.time === timestamp);
        }

        function updateStatus(text) {
            document.getElementById('status').textContent = text;
        }

        function showError(message) {
            updateStatus(`错误: ${message}`);
        }

        function attemptReconnect() {
            if (reconnectAttempts < 5) {
                reconnectAttempts++;
                setTimeout(initWebSocket, Math.min(3000, reconnectAttempts * 1000));
                updateStatus(`尝试重新连接 (${reconnectAttempts}/5)...`);
            }
        }

        // 事件处理
        function handleSymbolChange() {
            const newSymbol = document.getElementById('symbol').value.trim().toUpperCase();
            if (newSymbol !== currentSymbol) {
                currentSymbol = newSymbol;
                kLinesData = [];
                initWebSocket();
            }
        }

        function handleIntervalChange() {
            const newInterval = document.getElementById('interval').value;
            if (newInterval !== currentInterval) {
                currentInterval = newInterval;
                kLinesData = [];
                initWebSocket();
            }
        }

        // 初始化
        window.onload = () => {
            initChart();
            initWebSocket();
        };

        // 清理
        window.onbeforeunload = () => {
            if (ws) ws.close();
        };
    </script>
</body>
</html>